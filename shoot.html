<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Positive Emotion Shooter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e1e1e;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #2e2e2e;
            border: 2px solid #fff;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let score = 0;
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: 20,
            height: 20,
            baseSpeed: 7,
            maxSpeed: 14,
            dx: 0,
            accelerationRate: 0.2
        };

        let bullets = [];
        let negativeWords = [];
        let enemyInterval = 2000;

        const negativeEmotions = [
            "Depressed (沮丧的)", "Anxious (焦虑的)", "Stressed (压力大的)", "Frustrated (沮丧的)", "Angry (愤怒的)",
            "Lonely (孤独的)", "Tired (疲倦的)", "Bored (无聊的)", "Overwhelmed (不知所措的)", "Insecure (不安全的)",
            "Jealous (嫉妒的)", "Guilty (内疚的)", "Ashamed (羞愧的)", "Hopeless (绝望的)", "Pessimistic (悲观的)",
            "Lost (迷失的)", "Fearful (恐惧的)", "Melancholic (忧郁的)", "Troubled (烦恼的)", "Confused (困惑的)",
            "Disappointed (失望的)", "Regretful (后悔的)", "Self-conscious (自我意识过强的)", "Irritated (恼怒的)", "Hurt (受伤的)",
            "Sad (悲伤的)", "Panicked (惊慌的)", "Dissatisfied (不满的)", "Weary (疲惫的)", "Helpless (无助的)",
            "Nervous (紧张的)", "Distressed (苦恼的)", "Agitated (激动的)", "Worried (担心的)", "Terrified (恐惧的)",
            "Gloomy (阴郁的)", "Disheartened (灰心的)", "Moody (喜怒无常的)", "Unhappy (不快乐的)", "Furious (狂怒的)",
            "Heartbroken (心碎的)", "Dejected (沮丧的)", "Heavy-hearted (心情沉重的)", "Despondent (沮丧的)", "Sorrowful (悲伤的)",
            "Wistful (怀念的)", "Grief-stricken (悲痛欲绝的)", "Apprehensive (忧虑的)", "Horrified (惊恐的)", "Scared (害怕的)",
            "Concerned (担心的)", "Uneasy (不安的)", "Restless (焦躁不安的)", "Sullen (阴郁的)", "Bitter (痛苦的)",
            "Depressed (抑郁的)", "Downcast (沮丧的)", "Dismal (阴郁的)", "Cynical (愤世嫉俗的)", "Desperate (绝望的)",
            "Somber (忧郁的)", "Oppressed (压抑的)", "Low-spirited (情绪低落的)", "Negative (消极的)", "Apathetic (冷漠的)",
            "Powerless (无力的)", "Exhausted (筋疲力尽的)", "Weak (虚弱的)", "Fatigued (疲劳的)", "Drowsy (昏昏欲睡的)",
            "Fed up (厌烦的)", "Jaded (厌倦的)", "Disgusted (厌恶的)", "Averse (厌恶的)", "Hateful (可恨的)",
            "Resentful (怨恨的)", "Vengeful (报复心强的)", "Hostile (敌对的)", "Antagonistic (对抗的)", "Spiteful (恶意的)",
            "Enraged (暴怒的)", "Infuriated (激怒的)", "Annoyed (恼火的)", "Exasperated (恼怒的)", "Outraged (愤怒的)",
            "Livid (大怒的)", "Fuming (冒火的)", "Incensed (激怒的)", "Irate (发怒的)", "Seething (怒不可遏的)",
            "Troubled (烦恼的)", "Perturbed (不安的)", "Flustered (慌乱的)", "Unsettled (不安的)", "Disquieted (不安的)",
            "Dazed (茫然的)", "Distracted (心烦意乱的)", "Preoccupied (心事重重的)", "Absent-minded (心不在焉的)", "Inattentive (不专心的)"
        ];

        function drawPlayer() {
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function movePlayer() {
            updatePlayerSpeed();
            player.x += player.dx;

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
        }

        function createBullet() {
            const bulletDirections = [
                { dx: 0, dy: -1 },    // 垂直向上
                { dx: -0.5, dy: -0.866 },  // 左前方 (30度)
                { dx: 0.5, dy: -0.866 }    // 右前方 (30度)
            ];

            bulletDirections.forEach(direction => {
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 10,
                    speed: 15,
                    dx: direction.dx,
                    dy: direction.dy
                });
            });
        }

        function moveBullets() {
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.dx * bullet.speed;
                bullet.y += bullet.dy * bullet.speed;
                if (bullet.y < 0 || bullet.x < 0 || bullet.x > canvas.width) {
                    bullets.splice(index, 1);
                }
            });
        }

        function drawBullets() {
            ctx.fillStyle = '#ffff00';
            bullets.forEach(bullet => {
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                ctx.rotate(Math.atan2(bullet.dy, bullet.dx) + Math.PI / 2);
                ctx.fillRect(-bullet.width / 2, -bullet.height / 2, bullet.width, bullet.height);
                ctx.restore();
            });
        }

        function createNegativeWord() {
            const word = negativeEmotions[Math.floor(Math.random() * negativeEmotions.length)];
            negativeWords.push({
                word: word,
                x: Math.random() * (canvas.width - 100),
                y: 0,
                speed: 1 + Math.random() * 2
            });
        }

        function moveNegativeWords() {
            negativeWords.forEach((word, index) => {
                word.y += word.speed;
                if (word.y > canvas.height) {
                    negativeWords.splice(index, 1);
                }
            });
        }

        function drawNegativeWords() {
            ctx.font = '20px Arial';
            ctx.fillStyle = '#ff0000';
            negativeWords.forEach(word => {
                ctx.fillText(word.word, word.x, word.y);
            });
        }

        function detectCollision() {
            bullets.forEach((bullet, bIndex) => {
                negativeWords.forEach((word, wIndex) => {
                    if (
                        bullet.x < word.x + ctx.measureText(word.word).width &&
                        bullet.x + bullet.width > word.x &&
                        bullet.y < word.y &&
                        bullet.y + bullet.height > word.y - 20
                    ) {
                        setTimeout(() => {
                            bullets.splice(bIndex, 1);
                            negativeWords.splice(wIndex, 1);
                            score += 10;
                            document.getElementById('score').textContent = 'Score: ' + score;
                        }, 0);
                    }
                });
            });
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            movePlayer();
            moveBullets();
            moveNegativeWords();

            drawPlayer();
            drawBullets();
            drawNegativeWords();

            detectCollision();

            requestAnimationFrame(update);
        }

        let keyPressTime = {
            left: 0,
            right: 0
        };

        function keyDown(e) {
            if (e.key === 'ArrowRight' || e.key === 'd') {
                if (keyPressTime.right === 0) {
                    keyPressTime.right = Date.now();
                }
            } else if (e.key === 'ArrowLeft' || e.key === 'a') {
                if (keyPressTime.left === 0) {
                    keyPressTime.left = Date.now();
                }
            } else if (e.key === ' ') {
                createBullet();
            }
        }

        function keyUp(e) {
            if (e.key === 'ArrowRight' || e.key === 'd') {
                keyPressTime.right = 0;
                player.dx = 0;
            } else if (e.key === 'ArrowLeft' || e.key === 'a') {
                keyPressTime.left = 0;
                player.dx = 0;
            }
        }

        function updatePlayerSpeed() {
            let currentTime = Date.now();
            let rightElapsedTime = keyPressTime.right ? currentTime - keyPressTime.right : 0;
            let leftElapsedTime = keyPressTime.left ? currentTime - keyPressTime.left : 0;
            
            if (rightElapsedTime > 0 && leftElapsedTime > 0) {
                player.dx = 0;
            } else if (rightElapsedTime > 0) {
                player.dx = Math.min(player.maxSpeed, player.baseSpeed + rightElapsedTime * player.accelerationRate);
            } else if (leftElapsedTime > 0) {
                player.dx = -Math.min(player.maxSpeed, player.baseSpeed + leftElapsedTime * player.accelerationRate);
            } else {
                player.dx = 0;
            }
        }

        document.addEventListener('keydown', keyDown);
        document.addEventListener('keyup', keyUp);

        setInterval(createNegativeWord, enemyInterval);

        update();
    </script>
</body>
</html>
